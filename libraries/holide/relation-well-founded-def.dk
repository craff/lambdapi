
(; This file was generated by Holide. ;)

#REQUIRE hol.
#NAME relation_2Dwell_2Dfounded_2Ddef.

Data_2EBool_2E_3F : A : hol.type -> hol.term A.

(; Constant Relation.wellFounded ;)

def Relation_2EwellFounded : A : hol.type -> hol.term (hol.arr (hol.arr A (hol.arr A hol.bool)) hol.bool) :=
  A : hol.type => __11345_1 : hol.term (hol.arr A (hol.arr A hol.bool)) => hol.forall (hol.arr A hol.bool) (p_2 : hol.term (hol.arr A hol.bool) => hol.imp (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => p_2 x_3)) (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => hol.and (p_2 x_3) (hol.forall A (y_4 : hol.term A => hol.imp (__11345_1 y_4 x_3) (hol.not (p_2 y_4))))))).

(; Theorem: |- ((= Relation.wellFounded) \lambda _11345. (Data.Bool.! \lambda p. ((Data.Bool.==> (Data.Bool.? \lambda x. (p x))) (Data.Bool.? \lambda x. ((Data.Bool./\ (p x)) (Data.Bool.! \lambda y. ((Data.Bool.==> ((_11345 y) x)) (Data.Bool.~ (p y))))))))) ;)

(; dict ;)

def thm_0 : A : hol.type -> hol.proof (hol.eq (hol.arr (hol.arr A (hol.arr A hol.bool)) hol.bool) (Relation_2EwellFounded A) (__11345_1 : hol.term (hol.arr A (hol.arr A hol.bool)) => hol.forall (hol.arr A hol.bool) (p_2 : hol.term (hol.arr A hol.bool) => hol.imp (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => p_2 x_3)) (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => hol.and (p_2 x_3) (hol.forall A (y_4 : hol.term A => hol.imp (__11345_1 y_4 x_3) (hol.not (p_2 y_4))))))))) :=
  A : hol.type => hol.REFL (hol.arr (hol.arr A (hol.arr A hol.bool)) hol.bool) (Relation_2EwellFounded A).

(; Theorem: |- ((= _11345) _11345) ;)

(; dict ;)

def thm_1 : A : hol.type -> __11345_1 : hol.term (hol.arr A (hol.arr A hol.bool)) -> hol.proof (hol.eq (hol.arr A (hol.arr A hol.bool)) __11345_1 __11345_1) :=
  A : hol.type => __11345_1 : hol.term (hol.arr A (hol.arr A hol.bool)) => hol.REFL (hol.arr A (hol.arr A hol.bool)) __11345_1.

(; Theorem: |- ((= (Relation.wellFounded _11345)) (\lambda _11345. (Data.Bool.! \lambda p. ((Data.Bool.==> (Data.Bool.? \lambda x. (p x))) (Data.Bool.? \lambda x. ((Data.Bool./\ (p x)) (Data.Bool.! \lambda y. ((Data.Bool.==> ((_11345 y) x)) (Data.Bool.~ (p y)))))))) _11345)) ;)

(; dict ;)

def thm_2 : A : hol.type -> __11345_1 : hol.term (hol.arr A (hol.arr A hol.bool)) -> hol.proof (hol.eq hol.bool (Relation_2EwellFounded A __11345_1) ((__11345_2 : hol.term (hol.arr A (hol.arr A hol.bool)) => hol.forall (hol.arr A hol.bool) (p_3 : hol.term (hol.arr A hol.bool) => hol.imp (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_4 : hol.term A => p_3 x_4)) (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_4 : hol.term A => hol.and (p_3 x_4) (hol.forall A (y_5 : hol.term A => hol.imp (__11345_2 y_5 x_4) (hol.not (p_3 y_5)))))))) __11345_1)) :=
  A : hol.type => __11345_1 : hol.term (hol.arr A (hol.arr A hol.bool)) => hol.APP_THM (hol.arr A (hol.arr A hol.bool)) hol.bool (Relation_2EwellFounded A) (__11345_2 : hol.term (hol.arr A (hol.arr A hol.bool)) => hol.forall (hol.arr A hol.bool) (p_3 : hol.term (hol.arr A hol.bool) => hol.imp (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_4 : hol.term A => p_3 x_4)) (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_4 : hol.term A => hol.and (p_3 x_4) (hol.forall A (y_5 : hol.term A => hol.imp (__11345_2 y_5 x_4) (hol.not (p_3 y_5)))))))) __11345_1 __11345_1 (thm_0 A) (thm_1 A __11345_1).

(; Theorem: |- ((= (\lambda _11345. (Data.Bool.! \lambda p. ((Data.Bool.==> (Data.Bool.? \lambda x. (p x))) (Data.Bool.? \lambda x. ((Data.Bool./\ (p x)) (Data.Bool.! \lambda y. ((Data.Bool.==> ((_11345 y) x)) (Data.Bool.~ (p y)))))))) _11345)) (Data.Bool.! \lambda p. ((Data.Bool.==> (Data.Bool.? \lambda x. (p x))) (Data.Bool.? \lambda x. ((Data.Bool./\ (p x)) (Data.Bool.! \lambda y. ((Data.Bool.==> ((_11345 y) x)) (Data.Bool.~ (p y))))))))) ;)

(; dict ;)

def thm_3 : A : hol.type -> __11345_1 : hol.term (hol.arr A (hol.arr A hol.bool)) -> hol.proof (hol.eq hol.bool ((__11345_2 : hol.term (hol.arr A (hol.arr A hol.bool)) => hol.forall (hol.arr A hol.bool) (p_3 : hol.term (hol.arr A hol.bool) => hol.imp (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_4 : hol.term A => p_3 x_4)) (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_4 : hol.term A => hol.and (p_3 x_4) (hol.forall A (y_5 : hol.term A => hol.imp (__11345_2 y_5 x_4) (hol.not (p_3 y_5)))))))) __11345_1) (hol.forall (hol.arr A hol.bool) (p_2 : hol.term (hol.arr A hol.bool) => hol.imp (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => p_2 x_3)) (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => hol.and (p_2 x_3) (hol.forall A (y_4 : hol.term A => hol.imp (__11345_1 y_4 x_3) (hol.not (p_2 y_4))))))))) :=
  A : hol.type => __11345_1 : hol.term (hol.arr A (hol.arr A hol.bool)) => hol.BETA_CONV (hol.arr A (hol.arr A hol.bool)) hol.bool (__11345_2 : hol.term (hol.arr A (hol.arr A hol.bool)) => hol.forall (hol.arr A hol.bool) (p_3 : hol.term (hol.arr A hol.bool) => hol.imp (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_4 : hol.term A => p_3 x_4)) (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_4 : hol.term A => hol.and (p_3 x_4) (hol.forall A (y_5 : hol.term A => hol.imp (__11345_2 y_5 x_4) (hol.not (p_3 y_5)))))))) __11345_1.

(; Theorem: |- ((= (Relation.wellFounded _11345)) (Data.Bool.! \lambda p. ((Data.Bool.==> (Data.Bool.? \lambda x. (p x))) (Data.Bool.? \lambda x. ((Data.Bool./\ (p x)) (Data.Bool.! \lambda y. ((Data.Bool.==> ((_11345 y) x)) (Data.Bool.~ (p y))))))))) ;)

(; dict ;)

def thm_4 : A : hol.type -> __11345_1 : hol.term (hol.arr A (hol.arr A hol.bool)) -> hol.proof (hol.eq hol.bool (Relation_2EwellFounded A __11345_1) (hol.forall (hol.arr A hol.bool) (p_2 : hol.term (hol.arr A hol.bool) => hol.imp (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => p_2 x_3)) (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => hol.and (p_2 x_3) (hol.forall A (y_4 : hol.term A => hol.imp (__11345_1 y_4 x_3) (hol.not (p_2 y_4))))))))) :=
  A : hol.type => __11345_1 : hol.term (hol.arr A (hol.arr A hol.bool)) => hol.TRANS hol.bool (Relation_2EwellFounded A __11345_1) ((__11345_2 : hol.term (hol.arr A (hol.arr A hol.bool)) => hol.forall (hol.arr A hol.bool) (p_3 : hol.term (hol.arr A hol.bool) => hol.imp (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_4 : hol.term A => p_3 x_4)) (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_4 : hol.term A => hol.and (p_3 x_4) (hol.forall A (y_5 : hol.term A => hol.imp (__11345_2 y_5 x_4) (hol.not (p_3 y_5)))))))) __11345_1) (hol.forall (hol.arr A hol.bool) (p_2 : hol.term (hol.arr A hol.bool) => hol.imp (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => p_2 x_3)) (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => hol.and (p_2 x_3) (hol.forall A (y_4 : hol.term A => hol.imp (__11345_1 y_4 x_3) (hol.not (p_2 y_4)))))))) (thm_2 A __11345_1) (thm_3 A __11345_1).

(; Theorem: |- (Data.Bool.! \lambda _11345. ((= (Relation.wellFounded _11345)) (Data.Bool.! \lambda p. ((Data.Bool.==> (Data.Bool.? \lambda x. (p x))) (Data.Bool.? \lambda x. ((Data.Bool./\ (p x)) (Data.Bool.! \lambda y. ((Data.Bool.==> ((_11345 y) x)) (Data.Bool.~ (p y)))))))))) ;)

(; dict ;)

def thm_5 : A : hol.type -> hol.proof (hol.forall (hol.arr A (hol.arr A hol.bool)) (__11345_1 : hol.term (hol.arr A (hol.arr A hol.bool)) => hol.eq hol.bool (Relation_2EwellFounded A __11345_1) (hol.forall (hol.arr A hol.bool) (p_2 : hol.term (hol.arr A hol.bool) => hol.imp (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => p_2 x_3)) (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => hol.and (p_2 x_3) (hol.forall A (y_4 : hol.term A => hol.imp (__11345_1 y_4 x_3) (hol.not (p_2 y_4)))))))))) :=
  A : hol.type => __11345_1 : hol.term (hol.arr A (hol.arr A hol.bool)) => thm_4 A __11345_1.

(; Theorem: |- ((= (Relation.wellFounded r)) (Data.Bool.! \lambda p. ((Data.Bool.==> (Data.Bool.? \lambda x. (p x))) (Data.Bool.? \lambda x. ((Data.Bool./\ (p x)) (Data.Bool.! \lambda y. ((Data.Bool.==> ((r y) x)) (Data.Bool.~ (p y))))))))) ;)

(; dict ;)

def thm_6 : A : hol.type -> r_1 : hol.term (hol.arr A (hol.arr A hol.bool)) -> hol.proof (hol.eq hol.bool (Relation_2EwellFounded A r_1) (hol.forall (hol.arr A hol.bool) (p_2 : hol.term (hol.arr A hol.bool) => hol.imp (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => p_2 x_3)) (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => hol.and (p_2 x_3) (hol.forall A (y_4 : hol.term A => hol.imp (r_1 y_4 x_3) (hol.not (p_2 y_4))))))))) :=
  A : hol.type => r_1 : hol.term (hol.arr A (hol.arr A hol.bool)) => (A : hol.type => __11345_1 : hol.term (hol.arr A (hol.arr A hol.bool)) => thm_5 A __11345_1) A r_1.

(; Theorem: |- ((= (Data.Bool.! \lambda p. ((Data.Bool.==> (Data.Bool.? \lambda x. (p x))) (Data.Bool.? \lambda x. ((Data.Bool./\ (p x)) (Data.Bool.! \lambda y. ((Data.Bool.==> ((r y) x)) (Data.Bool.~ (p y))))))))) (Data.Bool.! \lambda p. ((Data.Bool.==> (Data.Bool.? \lambda x. (p x))) (Data.Bool.? \lambda x. ((Data.Bool./\ (p x)) (Data.Bool.! \lambda y. ((Data.Bool.==> ((r y) x)) (Data.Bool.~ (p y))))))))) ;)

(; dict ;)

def thm_7 : A : hol.type -> r_1 : hol.term (hol.arr A (hol.arr A hol.bool)) -> hol.proof (hol.eq hol.bool (hol.forall (hol.arr A hol.bool) (p_2 : hol.term (hol.arr A hol.bool) => hol.imp (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => p_2 x_3)) (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => hol.and (p_2 x_3) (hol.forall A (y_4 : hol.term A => hol.imp (r_1 y_4 x_3) (hol.not (p_2 y_4)))))))) (hol.forall (hol.arr A hol.bool) (p_2 : hol.term (hol.arr A hol.bool) => hol.imp (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => p_2 x_3)) (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => hol.and (p_2 x_3) (hol.forall A (y_4 : hol.term A => hol.imp (r_1 y_4 x_3) (hol.not (p_2 y_4))))))))) :=
  A : hol.type => r_1 : hol.term (hol.arr A (hol.arr A hol.bool)) => hol.REFL hol.bool (hol.forall (hol.arr A hol.bool) (p_2 : hol.term (hol.arr A hol.bool) => hol.imp (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => p_2 x_3)) (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => hol.and (p_2 x_3) (hol.forall A (y_4 : hol.term A => hol.imp (r_1 y_4 x_3) (hol.not (p_2 y_4)))))))).

(; Theorem: |- ((= (Data.Bool.! \lambda p. ((Data.Bool.==> (Data.Bool.? \lambda x. (p x))) (Data.Bool.? \lambda x. ((Data.Bool./\ (p x)) (Data.Bool.! \lambda y. ((Data.Bool.==> ((r y) x)) (Data.Bool.~ (p y))))))))) (Data.Bool.! \lambda p. ((Data.Bool.==> (Data.Bool.? \lambda x. (p x))) (Data.Bool.? \lambda x. ((Data.Bool./\ (p x)) (Data.Bool.! \lambda y. ((Data.Bool.==> ((r y) x)) (Data.Bool.~ (p y))))))))) ;)

(; dict ;)

def thm_8 : A : hol.type -> r_1 : hol.term (hol.arr A (hol.arr A hol.bool)) -> hol.proof (hol.eq hol.bool (hol.forall (hol.arr A hol.bool) (p_2 : hol.term (hol.arr A hol.bool) => hol.imp (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => p_2 x_3)) (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => hol.and (p_2 x_3) (hol.forall A (y_4 : hol.term A => hol.imp (r_1 y_4 x_3) (hol.not (p_2 y_4)))))))) (hol.forall (hol.arr A hol.bool) (p_2 : hol.term (hol.arr A hol.bool) => hol.imp (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => p_2 x_3)) (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => hol.and (p_2 x_3) (hol.forall A (y_4 : hol.term A => hol.imp (r_1 y_4 x_3) (hol.not (p_2 y_4))))))))) :=
  A : hol.type => r_1 : hol.term (hol.arr A (hol.arr A hol.bool)) => hol.SYM hol.bool (hol.forall (hol.arr A hol.bool) (p_2 : hol.term (hol.arr A hol.bool) => hol.imp (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => p_2 x_3)) (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => hol.and (p_2 x_3) (hol.forall A (y_4 : hol.term A => hol.imp (r_1 y_4 x_3) (hol.not (p_2 y_4)))))))) (hol.forall (hol.arr A hol.bool) (p_2 : hol.term (hol.arr A hol.bool) => hol.imp (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => p_2 x_3)) (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => hol.and (p_2 x_3) (hol.forall A (y_4 : hol.term A => hol.imp (r_1 y_4 x_3) (hol.not (p_2 y_4)))))))) (thm_7 A r_1).

(; Theorem: |- ((= (Relation.wellFounded r)) (Data.Bool.! \lambda p. ((Data.Bool.==> (Data.Bool.? \lambda x. (p x))) (Data.Bool.? \lambda x. ((Data.Bool./\ (p x)) (Data.Bool.! \lambda y. ((Data.Bool.==> ((r y) x)) (Data.Bool.~ (p y))))))))) ;)

(; dict ;)

def thm_9 : A : hol.type -> r_1 : hol.term (hol.arr A (hol.arr A hol.bool)) -> hol.proof (hol.eq hol.bool (Relation_2EwellFounded A r_1) (hol.forall (hol.arr A hol.bool) (p_2 : hol.term (hol.arr A hol.bool) => hol.imp (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => p_2 x_3)) (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => hol.and (p_2 x_3) (hol.forall A (y_4 : hol.term A => hol.imp (r_1 y_4 x_3) (hol.not (p_2 y_4))))))))) :=
  A : hol.type => r_1 : hol.term (hol.arr A (hol.arr A hol.bool)) => hol.TRANS hol.bool (Relation_2EwellFounded A r_1) (hol.forall (hol.arr A hol.bool) (p_2 : hol.term (hol.arr A hol.bool) => hol.imp (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => p_2 x_3)) (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => hol.and (p_2 x_3) (hol.forall A (y_4 : hol.term A => hol.imp (r_1 y_4 x_3) (hol.not (p_2 y_4)))))))) (hol.forall (hol.arr A hol.bool) (p_2 : hol.term (hol.arr A hol.bool) => hol.imp (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => p_2 x_3)) (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => hol.and (p_2 x_3) (hol.forall A (y_4 : hol.term A => hol.imp (r_1 y_4 x_3) (hol.not (p_2 y_4)))))))) (thm_6 A r_1) (thm_8 A r_1).

(; Theorem: |- (Data.Bool.! \lambda r. ((= (Relation.wellFounded r)) (Data.Bool.! \lambda p. ((Data.Bool.==> (Data.Bool.? \lambda x. (p x))) (Data.Bool.? \lambda x. ((Data.Bool./\ (p x)) (Data.Bool.! \lambda y. ((Data.Bool.==> ((r y) x)) (Data.Bool.~ (p y)))))))))) ;)

(; dict ;)

def thm_10 : A : hol.type -> hol.proof (hol.forall (hol.arr A (hol.arr A hol.bool)) (r_1 : hol.term (hol.arr A (hol.arr A hol.bool)) => hol.eq hol.bool (Relation_2EwellFounded A r_1) (hol.forall (hol.arr A hol.bool) (p_2 : hol.term (hol.arr A hol.bool) => hol.imp (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => p_2 x_3)) (Data_2EBool_2E_3F (hol.arr (hol.arr A hol.bool) hol.bool) (x_3 : hol.term A => hol.and (p_2 x_3) (hol.forall A (y_4 : hol.term A => hol.imp (r_1 y_4 x_3) (hol.not (p_2 y_4)))))))))) :=
  A : hol.type => r_1 : hol.term (hol.arr A (hol.arr A hol.bool)) => thm_9 A r_1.
