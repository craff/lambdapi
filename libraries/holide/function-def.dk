
(; This file was generated by Holide. ;)

#REQUIRE hol.
#NAME function_2Ddef.

(; Constant Function.o ;)

def Function_2Eo : A : hol.type -> C : hol.type -> B : hol.type -> hol.term (hol.arr (hol.arr B C) (hol.arr (hol.arr A B) (hol.arr A C))) :=
  A : hol.type => C : hol.type => B : hol.type => f_1 : hol.term (hol.arr B C) => g_2 : hol.term (hol.arr A B) => x_3 : hol.term A => f_1 (g_2 x_3).

(; Constant Function.id ;)

def Function_2Eid : A : hol.type -> hol.term (hol.arr A A) :=
  A : hol.type => x_1 : hol.term A => x_1.

(; Constant Function.const ;)

def Function_2Econst : B : hol.type -> A : hol.type -> hol.term (hol.arr A (hol.arr B A)) :=
  B : hol.type => A : hol.type => x_1 : hol.term A => y_2 : hol.term B => x_1.

(; Constant Function.Combinator.s ;)

def Function_2ECombinator_2Es : C : hol.type -> B : hol.type -> A : hol.type -> hol.term (hol.arr (hol.arr A (hol.arr B C)) (hol.arr (hol.arr A B) (hol.arr A C))) :=
  C : hol.type => B : hol.type => A : hol.type => f_1 : hol.term (hol.arr A (hol.arr B C)) => g_2 : hol.term (hol.arr A B) => x_3 : hol.term A => f_1 x_3 (g_2 x_3).

(; Constant Function.flip ;)

def Function_2Eflip : C : hol.type -> B : hol.type -> A : hol.type -> hol.term (hol.arr (hol.arr A (hol.arr B C)) (hol.arr B (hol.arr A C))) :=
  C : hol.type => B : hol.type => A : hol.type => f_1 : hol.term (hol.arr A (hol.arr B C)) => x_2 : hol.term B => y_3 : hol.term A => f_1 y_3 x_2.

(; Constant Function.Combinator.w ;)

def Function_2ECombinator_2Ew : B : hol.type -> A : hol.type -> hol.term (hol.arr (hol.arr A (hol.arr A B)) (hol.arr A B)) :=
  B : hol.type => A : hol.type => f_1 : hol.term (hol.arr A (hol.arr A B)) => x_2 : hol.term A => f_1 x_2 x_2.

(; Theorem: |- ((= Function.o) \lambda f. \lambda g. \lambda x. (f (g x))) ;)

(; dict ;)

def thm_0 : A : hol.type -> C : hol.type -> B : hol.type -> hol.proof (hol.eq (hol.arr (hol.arr B C) (hol.arr (hol.arr A B) (hol.arr A C))) (Function_2Eo A C B) (f_1 : hol.term (hol.arr B C) => g_2 : hol.term (hol.arr A B) => x_3 : hol.term A => f_1 (g_2 x_3))) :=
  A : hol.type => C : hol.type => B : hol.type => hol.REFL (hol.arr (hol.arr B C) (hol.arr (hol.arr A B) (hol.arr A C))) (Function_2Eo A C B).

(; Theorem: |- ((= Function.id) \lambda x. x) ;)

(; dict ;)

def thm_1 : A : hol.type -> hol.proof (hol.eq (hol.arr A A) (Function_2Eid A) (x_1 : hol.term A => x_1)) :=
  A : hol.type => hol.REFL (hol.arr A A) (Function_2Eid A).

(; Theorem: |- ((= Function.const) \lambda x. \lambda y. x) ;)

(; dict ;)

def thm_2 : B : hol.type -> A : hol.type -> hol.proof (hol.eq (hol.arr A (hol.arr B A)) (Function_2Econst B A) (x_1 : hol.term A => y_2 : hol.term B => x_1)) :=
  B : hol.type => A : hol.type => hol.REFL (hol.arr A (hol.arr B A)) (Function_2Econst B A).

(; Theorem: |- ((= Function.Combinator.s) \lambda f. \lambda g. \lambda x. ((f x) (g x))) ;)

(; dict ;)

def thm_3 : C : hol.type -> B : hol.type -> A : hol.type -> hol.proof (hol.eq (hol.arr (hol.arr A (hol.arr B C)) (hol.arr (hol.arr A B) (hol.arr A C))) (Function_2ECombinator_2Es C B A) (f_1 : hol.term (hol.arr A (hol.arr B C)) => g_2 : hol.term (hol.arr A B) => x_3 : hol.term A => f_1 x_3 (g_2 x_3))) :=
  C : hol.type => B : hol.type => A : hol.type => hol.REFL (hol.arr (hol.arr A (hol.arr B C)) (hol.arr (hol.arr A B) (hol.arr A C))) (Function_2ECombinator_2Es C B A).

(; Theorem: |- ((= Function.flip) \lambda f. \lambda x. \lambda y. ((f y) x)) ;)

(; dict ;)

def thm_4 : C : hol.type -> B : hol.type -> A : hol.type -> hol.proof (hol.eq (hol.arr (hol.arr A (hol.arr B C)) (hol.arr B (hol.arr A C))) (Function_2Eflip C B A) (f_1 : hol.term (hol.arr A (hol.arr B C)) => x_2 : hol.term B => y_3 : hol.term A => f_1 y_3 x_2)) :=
  C : hol.type => B : hol.type => A : hol.type => hol.REFL (hol.arr (hol.arr A (hol.arr B C)) (hol.arr B (hol.arr A C))) (Function_2Eflip C B A).

(; Theorem: |- ((= Function.Combinator.w) \lambda f. \lambda x. ((f x) x)) ;)

(; dict ;)

def thm_5 : B : hol.type -> A : hol.type -> hol.proof (hol.eq (hol.arr (hol.arr A (hol.arr A B)) (hol.arr A B)) (Function_2ECombinator_2Ew B A) (f_1 : hol.term (hol.arr A (hol.arr A B)) => x_2 : hol.term A => f_1 x_2 x_2)) :=
  B : hol.type => A : hol.type => hol.REFL (hol.arr (hol.arr A (hol.arr A B)) (hol.arr A B)) (Function_2ECombinator_2Ew B A).
